<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Castillo de Osaka ‚Äì VR Quest 3</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: #000;
      overflow: hidden;
    }
    .info-panel {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 20px;
      border-radius: 10px;
      z-index: 1000;
      max-width: 400px;
    }
    .vr-button {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%,-50%);
      background: #8B4513;
      color: white;
      border: none;
      padding: 20px 40px;
      font-size: 24px;
      border-radius: 10px;
      cursor: pointer;
      z-index: 1000;
    }
    .debug-info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
      z-index: 1000;
      max-width: 300px;
    }
    .back-button {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(220, 38, 38, 0.9);
      color: white;
      border: none;
      padding: 15px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      z-index: 1000;
      transition: all 0.3s ease;
    }
    .back-button:hover {
      background: rgba(220, 38, 38, 1);
      transform: scale(1.05);
    }
  </style>
</head>
<body>
  <div class="info-panel">
    <h3>üèØ Castillo de Osaka ‚Äì VR Quest 3</h3>
    <p id="tourInfo">Experiencia VR 360¬∞ del hist√≥rico Castillo de Osaka</p>
    <p id="webxrStatus">Verificando WebXR‚Ä¶</p>
    <p style="margin-top: 10px; font-size: 12px;">
      <a href="aframe-osaka-castle.html" style="color: #3b82f6; text-decoration: none;">
        üÜï Probar versi√≥n A-Frame completa
      </a>
    </p>
  </div>

  <button class="back-button" onclick="goBack()">
    üè† Volver al Dashboard
  </button>

  <button id="vrButton" class="vr-button" onclick="enterVR()">
    ü•Ω ENTRAR VR
  </button>

  <div id="debugInfo" class="debug-info">Debug: Cargando...</div>

  <script>
    // Debug inmediato
    console.log('Script iniciado');
    document.getElementById('debugInfo').textContent = 'Debug: Script cargado';
    
    // Variables globales
    let scene, camera, renderer, vrSession;
    const debugEl = document.getElementById('debugInfo');
    const statusEl = document.getElementById('webxrStatus');
    const tourInfoEl = document.getElementById('tourInfo');
    const vrButton = document.getElementById('vrButton');
    
    // Funci√≥n simple de debug
    function debug(message) {
      console.log('Debug:', message);
      debugEl.textContent = `Debug: ${message}`;
    }

    // Verificar WebXR de forma simple
    function checkWebXR() {
      debug('Verificando WebXR...');
      
      if (!navigator.xr) {
        statusEl.textContent = '‚ùå WebXR no disponible';
        statusEl.style.color = '#ef4444';
        debug('WebXR no disponible');
        return false;
      }

      navigator.xr.isSessionSupported('immersive-vr')
        .then(supported => {
          if (supported) {
            statusEl.textContent = '‚úÖ WebXR VR soportado';
            statusEl.style.color = '#10b981';
            vrButton.style.display = 'block';
            debug('VR soportado');
          } else {
            statusEl.textContent = '‚ùå WebXR VR no soportado';
            statusEl.style.color = '#ef4444';
            debug('VR no soportado');
          }
        })
        .catch(err => {
          statusEl.textContent = '‚ùå Error verificando WebXR';
          debug(`Error: ${err.message}`);
        });
    }

    // Inicializar escena b√°sica
    function initScene() {
      debug('Inicializando escena...');
      
      try {
        // Crear escena b√°sica
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB, 1);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Luz b√°sica
        const ambient = new THREE.AmbientLight(0xffd700, 0.4);
        const directional = new THREE.DirectionalLight(0xffd700, 0.6);
        directional.position.set(0, 10, 5);
        scene.add(ambient);
        scene.add(directional);

        // Skybox 360¬∞ con la imagen del Castillo de Osaka
        const skyboxGeometry = new THREE.SphereGeometry(100, 32, 32);
        const textureLoader = new THREE.TextureLoader();
        
        textureLoader.load('../../assets/osaka-castle.jpg', 
          (texture) => {
            // Skybox exitoso
            const skyboxMaterial = new THREE.MeshBasicMaterial({ 
              map: texture, 
              side: THREE.BackSide 
            });
            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
            scene.add(skybox);
            debug('Skybox Castillo de Osaka cargado correctamente');
          },
          undefined, // Progress callback
          (error) => {
            // Fallback si no carga la imagen
            console.error('Error cargando skybox:', error);
            debug('Error cargando skybox, usando color s√≥lido');
            const fallbackMaterial = new THREE.MeshBasicMaterial({ 
              color: 0x87CEEB, 
              side: THREE.BackSide 
            });
            const fallbackSkybox = new THREE.Mesh(skyboxGeometry, fallbackMaterial);
            scene.add(fallbackSkybox);
          }
        );

        // Avatar Gu√≠a como sprite (avatar.png) mirando siempre a la c√°mara
        const avatarTexture = new THREE.TextureLoader().load('../../assets/avatar.png');
        const avatarMaterial = new THREE.SpriteMaterial({ map: avatarTexture, color: 0xffffff });
        const avatar = new THREE.Sprite(avatarMaterial);
        avatar.scale.set(0.8, 0.8, 1); // tama√±o visible
        avatar.position.set(0, 1.2, -2);
        avatar.userData = {
          name: 'Avatar Gu√≠a',
          info: 'Tu gu√≠a virtual del Castillo de Osaka. Haz click para comenzar la historia interactiva.',
          type: 'avatar'
        };
        scene.add(avatar);

        // Solo el avatar y botones de historia son interactivos
        const interactables = [avatar];

        // Variables para interacci√≥n
        let selectedObject = null;
        let lastSelectedObject = null;
        let isInfoPanelOpen = false;
        
        // Variables para la historia
        let currentDialogueIndex = 0;
        let isStoryActive = false;
        let backgroundChanged = false;
        let currentSpeech = null;
        let isMuted = false;
        let isVoiceEnabled = true;
        let speechRate = 1.0;
        
        // Story data for Osaka Castle (igual que en A-Frame)
        const castleStory = [
            {
                text: "¬°Hola! Bienvenido al Castillo de Osaka. Soy tu gu√≠a virtual y te acompa√±ar√© en este viaje hist√≥rico.",
                showLookPrompt: false
            },
            {
                text: "¬øSab√≠as que este castillo fue construido en 1583 por Toyotomi Hideyoshi? Fue el castillo m√°s grande de Jap√≥n en su √©poca.",
                showLookPrompt: true
            },
            {
                text: "Un dato curioso: el castillo original fue destruido por un rayo en 1615, pero fue reconstruido en 1620. ¬°La naturaleza puede ser impredecible!",
                showLookPrompt: true
            },
            {
                text: "La torre principal que ves tiene 8 pisos y est√° cubierta con tejas doradas. ¬°Era un s√≠mbolo de poder y riqueza!",
                showLookPrompt: true
            },
            {
                text: "Durante la Segunda Guerra Mundial, el castillo fue bombardeado, pero fue reconstruido en 1997. ¬°Es un verdadero superviviente de la historia!",
                showLookPrompt: true
            },
            {
                text: "Ahora puedes explorar libremente. Haz click en m√≠ si necesitas m√°s informaci√≥n. ¬°Disfruta tu visita al Castillo de Osaka!",
                showLookPrompt: false
            }
        ];

        // Raycaster para detectar colisiones
        const raycaster = new THREE.Raycaster();
        const tempMatrix = new THREE.Matrix4();

        // Configurar controladores VR
        const controller1 = renderer.xr.getController(0); // Controlador derecho
        const controller2 = renderer.xr.getController(1); // Controlador izquierdo
        scene.add(controller1);
        scene.add(controller2);

        // Crear indicadores visuales para los controladores
        function createControllerGrip(controller) {
          const geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, -1)
          ]);
          const line = new THREE.Line(geometry);
          line.name = 'line';
          line.scale.z = 5;
          controller.add(line);
        }

        function createControllerCursor(controller) {
          const geometry = new THREE.RingGeometry(0.02, 0.04, 32);
          const material = new THREE.MeshBasicMaterial();
          const cursor = new THREE.Mesh(geometry, material);
          cursor.name = 'cursor';
          cursor.visible = false;
          controller.add(cursor);
        }

        // Agregar indicadores a ambos controladores
        createControllerGrip(controller1);
        createControllerCursor(controller1);
        createControllerGrip(controller2);
        createControllerCursor(controller2);

        // Funci√≥n para restaurar colores originales
        function restoreOriginalColors() {
          if (lastSelectedObject) {
            if (lastSelectedObject === avatar) {
              lastSelectedObject.material.color.setHex(0xffd700); // Dorado para avatar
            } else if (lastSelectedObject === tower) {
              lastSelectedObject.material.color.setHex(0x8B4513); // Marr√≥n para torre
            } else if (lastSelectedObject === wall) {
              lastSelectedObject.material.color.setHex(0x696969); // Gris para muro
            }
            lastSelectedObject = null;
          }
        }

        // Funci√≥n para cerrar panel de informaci√≥n
        function closeInfoPanel() {
          const existingPanel = scene.getObjectByName('infoPanel');
          if (existingPanel) {
            scene.remove(existingPanel);
            isInfoPanelOpen = false;
          }
        }

        // Funci√≥n para mostrar informaci√≥n del objeto
        function showObjectInfo(object) {
          if (object.userData && object.userData.name && object.userData.name === 'Avatar Gu√≠a') {
            // Si es el avatar, iniciar la historia
            if (!isStoryActive) {
              startStory();
            }
          }
        }

        // Funci√≥n para iniciar la historia
        function startStory() {
          if (isStoryActive) return;
          
          isStoryActive = true;
          currentDialogueIndex = 0;
          debug('Iniciando historia del Castillo de Osaka');
          
          // Mostrar primer di√°logo
          showDialogue();
        }

        // Funci√≥n para mostrar di√°logo actual
        function showDialogue() {
          if (currentDialogueIndex >= castleStory.length) {
            endStory();
            return;
          }
          
          const dialogue = castleStory[currentDialogueIndex];
          debug(`Di√°logo ${currentDialogueIndex + 1}: ${dialogue.text.substring(0, 50)}...`);
          
          // Remover panel anterior si existe
          closeInfoPanel();
          
          // Crear panel 3D de di√°logo
          const panelGroup = new THREE.Group();
          panelGroup.name = 'infoPanel';
          
          // Fondo del panel
          const panelGeometry = new THREE.PlaneGeometry(2, 1.2);
          const panelMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            transparent: true, 
            opacity: 0.95 
          });
          const panel = new THREE.Mesh(panelGeometry, panelMaterial);
          panelGroup.add(panel);
          
          // Borde dorado
          const borderGeometry = new THREE.PlaneGeometry(2.2, 1.4);
          const borderMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffd700, 
            transparent: true, 
            opacity: 0.8 
          });
          const border = new THREE.Mesh(borderGeometry, borderMaterial);
          border.position.z = -0.01;
          panelGroup.add(border);
          
          // Crear canvas para el texto
          const canvas = document.createElement('canvas');
          canvas.width = 512;
          canvas.height = 384;
          const context = canvas.getContext('2d');
          
          // Configurar el canvas
          context.fillStyle = '#ffffff';
          context.fillRect(0, 0, canvas.width, canvas.height);
          
          // Dibujar texto
          context.fillStyle = '#8B4513';
          context.font = 'bold 24px Arial';
          context.textAlign = 'center';
          
          // T√≠tulo
          context.fillText('Gato bebe', canvas.width/2, 40);
          
          // Informaci√≥n (dividida en l√≠neas)
          context.fillStyle = '#333333';
          context.font = '18px Arial';
          const words = dialogue.text.split(' ');
          let lines = [];
          let currentLine = '';
          
          for (let word of words) {
            const testLine = currentLine + word + ' ';
            if (context.measureText(testLine).width > canvas.width - 40) {
              lines.push(currentLine);
              currentLine = word + ' ';
            } else {
              currentLine = testLine;
            }
          }
          lines.push(currentLine);
          
          // Dibujar l√≠neas de informaci√≥n
          lines.forEach((line, index) => {
            context.fillText(line, canvas.width/2, 80 + (index * 25));
          });
          
          // Crear textura del canvas
          const texture = new THREE.CanvasTexture(canvas);
          const textGeometry = new THREE.PlaneGeometry(2, 1.2);
          const textMaterial = new THREE.MeshBasicMaterial({ 
            map: texture,
            transparent: true,
            side: THREE.DoubleSide
          });
          const textMesh = new THREE.Mesh(textGeometry, textMaterial);
          panelGroup.add(textMesh);
          
          // Bot√≥n Continuar
          const buttonGeometry = new THREE.PlaneGeometry(0.6, 0.2);
          const buttonMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
          const continueButton = new THREE.Mesh(buttonGeometry, buttonMaterial);
          continueButton.position.set(0, -0.6, 0.01);
          continueButton.userData = { type: 'continueButton' };
          panelGroup.add(continueButton);
          
          // Texto del bot√≥n
          const buttonCanvas = document.createElement('canvas');
          buttonCanvas.width = 256;
          buttonCanvas.height = 64;
          const buttonContext = buttonCanvas.getContext('2d');
          buttonContext.fillStyle = '#8B4513';
          buttonContext.fillRect(0, 0, buttonCanvas.width, buttonCanvas.height);
          buttonContext.fillStyle = '#ffffff';
          buttonContext.font = 'bold 20px Arial';
          buttonContext.textAlign = 'center';
          buttonContext.fillText('Continuar', buttonCanvas.width/2, 40);
          
          const buttonTexture = new THREE.CanvasTexture(buttonCanvas);
          const buttonTextGeometry = new THREE.PlaneGeometry(0.6, 0.2);
          const buttonTextMaterial = new THREE.MeshBasicMaterial({ 
            map: buttonTexture,
            transparent: true,
            side: THREE.DoubleSide
          });
          const buttonTextMesh = new THREE.Mesh(buttonTextGeometry, buttonTextMaterial);
          buttonTextMesh.position.set(0, -0.6, 0.02);
          panelGroup.add(buttonTextMesh);
          
          // Bot√≥n Avanzar (solo despu√©s del segundo di√°logo)
          if (currentDialogueIndex === 1 && !backgroundChanged) {
            const advanceButtonGeometry = new THREE.PlaneGeometry(0.6, 0.2);
            const advanceButtonMaterial = new THREE.MeshBasicMaterial({ color: 0xffd700 });
            const advanceButton = new THREE.Mesh(advanceButtonGeometry, advanceButtonMaterial);
            advanceButton.position.set(0, -0.8, 0.01);
            advanceButton.userData = { type: 'advanceButton' };
            panelGroup.add(advanceButton);
            
            // Texto del bot√≥n Avanzar
            const advanceButtonCanvas = document.createElement('canvas');
            advanceButtonCanvas.width = 256;
            advanceButtonCanvas.height = 64;
            const advanceButtonContext = advanceButtonCanvas.getContext('2d');
            advanceButtonContext.fillStyle = '#ffd700';
            advanceButtonContext.fillRect(0, 0, advanceButtonCanvas.width, advanceButtonCanvas.height);
            advanceButtonContext.fillStyle = '#333333';
            advanceButtonContext.font = 'bold 20px Arial';
            advanceButtonContext.textAlign = 'center';
            advanceButtonContext.fillText('Avanzar', advanceButtonCanvas.width/2, 40);
            
            const advanceButtonTexture = new THREE.CanvasTexture(advanceButtonCanvas);
            const advanceButtonTextGeometry = new THREE.PlaneGeometry(0.6, 0.2);
            const advanceButtonTextMaterial = new THREE.MeshBasicMaterial({ 
              map: advanceButtonTexture,
              transparent: true,
              side: THREE.DoubleSide
            });
            const advanceButtonTextMesh = new THREE.Mesh(advanceButtonTextGeometry, advanceButtonTextMaterial);
            advanceButtonTextMesh.position.set(0, -0.8, 0.02);
            panelGroup.add(advanceButtonTextMesh);
          }
          
          // Agregar botones a interactables
          interactables.push(continueButton);
          if (currentDialogueIndex === 1 && !backgroundChanged) {
            const advanceButton = panelGroup.children.find(child => child.userData.type === 'advanceButton');
            if (advanceButton) {
              interactables.push(advanceButton);
            }
          }
          
          // Posicionar el panel cerca del avatar
          const avatarPosition = avatar.position.clone();
          panelGroup.position.copy(avatarPosition);
          panelGroup.position.y += 1.5; // Elevar m√°s
          panelGroup.position.z += 0.5; // Acercar a la c√°mara
          
          // Hacer que el panel mire hacia la c√°mara
          panelGroup.lookAt(camera.position);
          
          scene.add(panelGroup);
          isInfoPanelOpen = true;
          
          // Reproducir audio si est√° habilitado
          speakText(dialogue.text);
        }

        // Funci√≥n para continuar al siguiente di√°logo
        function nextDialogue() {
          currentDialogueIndex++;
          showDialogue();
        }

        // Funci√≥n para avanzar a la siguiente escena
        function advanceToNextScene() {
          debug('Avanzando a la siguiente escena...');
          backgroundChanged = true;
          
          // Cambiar skybox a la segunda imagen
          const textureLoader = new THREE.TextureLoader();
          textureLoader.load('../../assets/osaka-castle2.jpg', 
            (texture) => {
              // Encontrar y reemplazar el skybox
              scene.traverse((child) => {
                if (child.geometry && child.geometry.type === 'SphereGeometry' && child.material.map) {
                  child.material.map = texture;
                  child.material.needsUpdate = true;
                }
              });
              debug('Skybox cambiado a osaka-castle2.jpg');
            },
            undefined,
            (error) => {
              debug('Error cargando segunda imagen: ' + error.message);
            }
          );
          
          // Continuar con el siguiente di√°logo
          currentDialogueIndex++;
          showDialogue();
        }

        // Funci√≥n para terminar la historia
        function endStory() {
          isStoryActive = false;
          closeInfoPanel();
          debug('Historia del Castillo de Osaka completada');
        }

        // Funci√≥n para Text-to-Speech
        function speakText(text) {
          if (!isVoiceEnabled || isMuted) return;
          
          // Detener cualquier speech actual
          if (currentSpeech) {
            speechSynthesis.cancel();
          }
          
          if ('speechSynthesis' in window) {
            const ensureVoices = () => new Promise(resolve => {
              const v = speechSynthesis.getVoices();
              if (v && v.length) return resolve(v);
              speechSynthesis.onvoiceschanged = () => resolve(speechSynthesis.getVoices());
              setTimeout(() => resolve(speechSynthesis.getVoices()), 500);
            });

            ensureVoices().then(voices => {
              const utterance = new SpeechSynthesisUtterance(text);
              utterance.rate = speechRate;
              utterance.pitch = 1.0;
              utterance.volume = 0.9;

              const spanishVoice = voices.find(voice => 
                (voice.lang && voice.lang.toLowerCase().startsWith('es')) || 
                (voice.name && (voice.name.includes('Spanish') || voice.name.includes('Espa√±ol')))
              );
              if (spanishVoice) utterance.voice = spanishVoice;

              currentSpeech = utterance;
              try {
                speechSynthesis.speak(utterance);
                debug('Reproduciendo audio: ' + text.substring(0, 30) + '...');
              } catch (e) {
                debug('Error TTS: ' + e.message);
              }
            });
          }
        }

        // Funci√≥n para manejar selecci√≥n
        function onSelectStart(event) {
          const controller = event.target;
          
          // Configurar raycaster desde el controlador
          tempMatrix.identity().extractRotation(controller.matrixWorld);
          raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
          raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

          // Detectar objetos intersectados
          const intersects = raycaster.intersectObjects(interactables);
          
          debug(`Objetos intersectados: ${intersects.length}`);
          
          if (intersects.length > 0) {
            const hitObject = intersects[0].object;
            debug(`Objeto golpeado: ${hitObject.name || hitObject.userData.name || hitObject.userData.type}`);
            
            // Verificar si es un bot√≥n de la historia
            if (hitObject.userData && hitObject.userData.type) {
              if (hitObject.userData.type === 'continueButton') {
                debug('Bot√≥n Continuar presionado');
                nextDialogue();
                return;
              } else if (hitObject.userData.type === 'advanceButton') {
                debug('Bot√≥n Avanzar presionado');
                advanceToNextScene();
                return;
              }
            }
            
            // Manejar selecci√≥n del avatar
            if (hitObject === avatar) {
              showObjectInfo(hitObject);
              debug('Avatar seleccionado - iniciando historia');
              
              // Cambiar color del avatar
              hitObject.material.color.setHex(0x00ff00); // Verde
              lastSelectedObject = hitObject;
            }
          }
        }

        // Funci√≥n para actualizar indicadores visuales
        function updateControllerIndicators() {
          [controller1, controller2].forEach(controller => {
            const line = controller.getObjectByName('line');
            const cursor = controller.getObjectByName('cursor');
            
            if (line && cursor) {
              // Configurar raycaster
              tempMatrix.identity().extractRotation(controller.matrixWorld);
              raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
              raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

              // Detectar objetos
              const intersects = raycaster.intersectObjects(interactables);
              
              if (intersects.length > 0) {
                // Mostrar cursor en el punto de intersecci√≥n
                cursor.position.copy(intersects[0].point);
                cursor.lookAt(controller.position);
                cursor.visible = true;
                
                // Cambiar color seg√∫n el tipo de objeto
                const hitObject = intersects[0].object;
                cursor.material.color.setHex(0xffff00); // Amarillo para objetos informativos
                line.material.color.setHex(0xffff00);
                
                line.scale.z = intersects[0].distance;
              } else {
                // Ocultar cursor si no hay objetos
                cursor.visible = false;
                
                // Color normal para el rayo
                line.material.color.setHex(0xffffff);
                line.scale.z = 5;
              }
            }
          });
        }

        // Funci√≥n para mostrar coordenadas de objetos
        function showObjectCoordinates() {
          const coordinates = [];
          
          // Coordenadas del avatar
          coordinates.push(`Avatar: (${avatar.position.x.toFixed(2)}, ${avatar.position.y.toFixed(2)}, ${avatar.position.z.toFixed(2)})`);
          
          // Mostrar en debug
          debug(`Posiciones: ${coordinates.join(' | ')}`);
        }

        // Funci√≥n para actualizar coordenadas cada segundo
        function updateCoordinates() {
          showObjectCoordinates();
        }

        // Actualizar coordenadas cada segundo
        setInterval(updateCoordinates, 1000);

        // Variable para controlar la animaci√≥n
        let animationId = null;

        // Desbloquear audio/TTS en el primer gesto del usuario (requisito en Quest/Chromium)
        const unlockAudioOnce = () => {
          try { speechSynthesis.cancel(); } catch(e) {}
          window.removeEventListener('click', unlockAudioOnce);
          controller1.removeEventListener('selectstart', unlockAudioOnce);
          controller2.removeEventListener('selectstart', unlockAudioOnce);
          debug('Audio/TTS desbloqueado por interacci√≥n del usuario');
        };
        window.addEventListener('click', unlockAudioOnce, { once: true });
        controller1.addEventListener('selectstart', unlockAudioOnce, { once: true });
        controller2.addEventListener('selectstart', unlockAudioOnce, { once: true });

        // Agregar eventos a ambos controladores
        controller1.addEventListener('selectstart', onSelectStart);
        controller2.addEventListener('selectstart', onSelectStart);

        // Funci√≥n de animaci√≥n que funciona en ambos modos
        function animate() {
          // Rotar el avatar suavemente
          avatar.rotation.y += 0.01;
          
          // Actualizar indicadores visuales
          updateControllerIndicators();
          
          // Renderizar
          renderer.render(scene, camera);
          
          // Continuar animaci√≥n solo en modo no-VR
          if (!renderer.xr.isPresenting) {
            animationId = requestAnimationFrame(animate);
          }
        }

        // Iniciar animaci√≥n no-VR
        animate();

        // Manejar entrada/salida de VR
        renderer.xr.addEventListener('sessionstart', () => {
          debug('Sesi√≥n VR iniciada - Usa el gatillo para interactuar');
        });

        renderer.xr.addEventListener('sessionend', () => {
          debug('Sesi√≥n VR terminada');
          // Reanudar animaci√≥n no-VR
          animate();
        });

        debug('Escena del Castillo de Osaka lista');
      } catch (err) {
        debug(`Error en escena: ${err.message}`);
        console.error(err);
      }
    }

    // Funci√≥n para entrar en VR
    async function enterVR() {
      debug('Intentando entrar en VR...');
      
      if (!navigator.xr) {
        debug('WebXR no disponible');
        return;
      }

      try {
        vrButton.style.display = 'none';
        
        const session = await navigator.xr.requestSession('immersive-vr', {
          optionalFeatures: ['local-floor', 'bounded-floor'],
          requiredFeatures: ['local']
        });

        await renderer.xr.setSession(session);
        renderer.xr.setReferenceSpaceType('local');
        
        debug('VR activo - Interact√∫a con los objetos del castillo');
        
        // Configurar el loop de animaci√≥n para VR
        renderer.setAnimationLoop((time, frame) => {
          // La animaci√≥n se maneja en la funci√≥n animate()
          renderer.render(scene, camera);
        });
      } catch (err) {
        debug(`Error VR: ${err.message}`);
        vrButton.style.display = 'block';
        console.error(err);
      }
    }

    // Funci√≥n para volver al dashboard
    function goBack() {
      window.location.href = '../dashboard.html';
    }

    // Inicializaci√≥n cuando el DOM est√© listo
    document.addEventListener('DOMContentLoaded', function() {
      debug('DOM listo');
      
      // Cargar Three.js din√°micamente
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/three@0.151.0/build/three.min.js';
      script.onload = function() {
        debug('Three.js cargado');
        window.THREE = THREE;
        checkWebXR();
        initScene();
        debug('Inicializaci√≥n completa');
      };
      script.onerror = function() {
        debug('Error cargando Three.js');
      };
      document.head.appendChild(script);
    });

    // Hacer funciones globales
    window.enterVR = enterVR;
    window.goBack = goBack;
  </script>
</body>
</html>
