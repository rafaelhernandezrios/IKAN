<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Laboratorio Mirai â€“ Interactivo VR</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: #000;
      overflow: hidden;
    }
    .info-panel {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 20px;
      border-radius: 10px;
      z-index: 1000;
      max-width: 400px;
    }
    .vr-button {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%,-50%);
      background: #1e3a8a;
      color: white;
      border: none;
      padding: 20px 40px;
      font-size: 24px;
      border-radius: 10px;
      cursor: pointer;
      z-index: 1000;
    }
    .debug-info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
      z-index: 1000;
      max-width: 300px;
    }
  </style>
</head>
<body>
  <div class="info-panel">
    <h3>ðŸ¥½ Laboratorio Mirai â€“ Interactivo VR</h3>
    <p id="tourInfo">Cargando tour...</p>
    <p id="webxrStatus">Verificando WebXRâ€¦</p>
    <p style="margin-top: 10px; font-size: 12px;">
      <a href="aframe-mirai-skybox-fixed.html" style="color: #3b82f6; text-decoration: none;">
        ðŸ†• Probar versiÃ³n A-Frame completa
      </a>
    </p>
  </div>

  <button id="vrButton" class="vr-button" onclick="enterVR()">
    ðŸ¥½ ENTRAR VR
  </button>

  <div id="debugInfo" class="debug-info">Debug: Cargando...</div>

  <script>
    // Debug inmediato
    console.log('Script iniciado');
    document.getElementById('debugInfo').textContent = 'Debug: Script cargado';
    
    // Variables globales
    let scene, camera, renderer, vrSession;
    const debugEl = document.getElementById('debugInfo');
    const statusEl = document.getElementById('webxrStatus');
    const tourInfoEl = document.getElementById('tourInfo');
    const vrButton = document.getElementById('vrButton');
    
    // Get selected tour
    const selectedTour = localStorage.getItem('gca_virtual_selected_tour') || 'japan';
    
    // Tour configurations
    const tourConfigs = {
        japan: {
            name: 'ðŸ‡¯ðŸ‡µ JapÃ³n - Laboratorio Mirai',
            description: 'Explora el Laboratorio Mirai Innovation en JapÃ³n',
            skyboxImage: 'https://ikan-bucket.s3.us-east-2.amazonaws.com/mirai_lab.jpg'
        },
        mexico: {
            name: 'ðŸ‡²ðŸ‡½ MÃ©xico - Centro de InnovaciÃ³n',
            description: 'Descubre la innovaciÃ³n tecnolÃ³gica en MÃ©xico',
            skyboxImage: 'https://ikan-bucket.s3.us-east-2.amazonaws.com/mirai_lab.jpg' // Same for now, can be changed later
        },
        france: {
            name: 'ðŸ‡«ðŸ‡· Francia - Centro de InvestigaciÃ³n',
            description: 'Visita centros de investigaciÃ³n en Francia',
            skyboxImage: 'https://ikan-bucket.s3.us-east-2.amazonaws.com/mirai_lab.jpg' // Same for now, can be changed later
        }
    };
    
    // Update tour info
    const currentTour = tourConfigs[selectedTour];
    tourInfoEl.textContent = `${currentTour.name} - ${currentTour.description}`;

    // FunciÃ³n simple de debug
    function debug(message) {
      console.log('Debug:', message);
      debugEl.textContent = `Debug: ${message}`;
    }

    // Verificar WebXR de forma simple
    function checkWebXR() {
      debug('Verificando WebXR...');
      
      if (!navigator.xr) {
        statusEl.textContent = 'âŒ WebXR no disponible';
        statusEl.style.color = '#ef4444';
        debug('WebXR no disponible');
        return false;
      }

      navigator.xr.isSessionSupported('immersive-vr')
        .then(supported => {
          if (supported) {
            statusEl.textContent = 'âœ… WebXR VR soportado';
            statusEl.style.color = '#10b981';
            vrButton.style.display = 'block';
            debug('VR soportado');
          } else {
            statusEl.textContent = 'âŒ WebXR VR no soportado';
            statusEl.style.color = '#ef4444';
            debug('VR no soportado');
          }
        })
        .catch(err => {
          statusEl.textContent = 'âŒ Error verificando WebXR';
          debug(`Error: ${err.message}`);
        });
    }

    // Inicializar escena bÃ¡sica
    function initScene() {
      debug('Inicializando escena...');
      
      try {
        // Crear escena bÃ¡sica
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB, 1);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Luz bÃ¡sica
        const ambient = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambient);

        // Skybox 360Â° con la imagen de Mirai Lab
        const skyboxGeometry = new THREE.SphereGeometry(100, 32, 32);
        const textureLoader = new THREE.TextureLoader();
        
        textureLoader.load(currentTour.skyboxImage, 
          (texture) => {
            // Skybox exitoso
            const skyboxMaterial = new THREE.MeshBasicMaterial({ 
              map: texture, 
              side: THREE.BackSide 
            });
            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
            scene.add(skybox);
            debug('Skybox Mirai Lab cargado correctamente');
          },
          undefined, // Progress callback
          (error) => {
            // Fallback si no carga la imagen
            console.error('Error cargando skybox:', error);
            debug('Error cargando skybox, usando color sÃ³lido');
            const fallbackMaterial = new THREE.MeshBasicMaterial({ 
              color: 0x87CEEB, 
              side: THREE.BackSide 
            });
            const fallbackSkybox = new THREE.Mesh(skyboxGeometry, fallbackMaterial);
            scene.add(fallbackSkybox);
          }
        );

        // Un cubo interactivo
        const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const material = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(0, 1.6, -2);
        scene.add(cube);

        // Crear objetos interactivos estÃ¡ticos que representan elementos del laboratorio
        const staticObjects = [];

        // Robot Pepper (robot blanco)
        const pepperGeometry = new THREE.BoxGeometry(0.3, 0.6, 0.3);
        const pepperMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const pepper = new THREE.Mesh(pepperGeometry, pepperMaterial);
        pepper.position.set(1.8, 0.8, -2.8); // Bajado de 1.2 a 0.8
        pepper.userData = {
          name: 'Pepper Robot',
          info: 'Robot humanoide Pepper de SoftBank Robotics. DiseÃ±ado para interacciÃ³n social y asistencia en entornos comerciales y educativos.',
          type: 'robot'
        };
        scene.add(pepper);
        staticObjects.push(pepper);

        // Robot Unitree Go2 (perro robot)
        const unitreeGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.3);
        const unitreeMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 }); // Gris claro
        const unitree = new THREE.Mesh(unitreeGeometry, unitreeMaterial);
        unitree.position.set(0.67,-0.93,1.87); // Posicionado en el centro-derecha, mÃ¡s cerca para ser visible
        unitree.userData = {
          name: 'Unitree Go2',
          info: 'Robot cuadrÃºpedo Unitree Go2. Robot perro de alta movilidad diseÃ±ado para investigaciÃ³n en locomociÃ³n, exploraciÃ³n y asistencia. Equipado con sensores avanzados y control de movimiento preciso.',
          type: 'robot'
        };
        scene.add(unitree);
        staticObjects.push(unitree);

        // Agregar todos los objetos a la lista de interactivos
        const interactables = [cube, ...staticObjects];

        // Variables para interacciÃ³n
        let grabbedObject = null;
        let selectedObject = null;
        let lastSelectedObject = null; // Para rastrear el objeto anteriormente seleccionado
        let isInfoPanelOpen = false; // Para rastrear si el panel estÃ¡ abierto
        let isVideoPlaying = false; // Para rastrear si el video estÃ¡ reproduciÃ©ndose
        let videoScene, videoCamera; // Para la escena del video
        let originalScene, originalCamera; // Para guardar la escena original
        let currentVideo = null; // Para rastrear el video actual

        // Raycaster para detectar colisiones
        const raycaster = new THREE.Raycaster();
        const tempMatrix = new THREE.Matrix4();

        // Configurar controladores VR
        const controller1 = renderer.xr.getController(0); // Controlador derecho
        const controller2 = renderer.xr.getController(1); // Controlador izquierdo
        scene.add(controller1);
        scene.add(controller2);

        // Crear indicadores visuales para los controladores
        function createControllerGrip(controller) {
          const geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, -1)
          ]);
          const line = new THREE.Line(geometry);
          line.name = 'line';
          line.scale.z = 5;
          controller.add(line);
        }

        function createControllerCursor(controller) {
          const geometry = new THREE.RingGeometry(0.02, 0.04, 32);
          const material = new THREE.MeshBasicMaterial();
          const cursor = new THREE.Mesh(geometry, material);
          cursor.name = 'cursor';
          cursor.visible = false;
          controller.add(cursor);
        }

        // Agregar indicadores a ambos controladores
        createControllerGrip(controller1);
        createControllerCursor(controller1);
        createControllerGrip(controller2);
        createControllerCursor(controller2);

        // FunciÃ³n para restaurar colores originales
        function restoreOriginalColors() {
          if (lastSelectedObject) {
            if (lastSelectedObject === cube) {
              lastSelectedObject.material.color.setHex(0xffaa00); // Amarillo para cubo
            } else {
              lastSelectedObject.material.color.setHex(0xffffff); // Blanco para Pepper
            }
            lastSelectedObject = null;
          }
        }

        // FunciÃ³n para cerrar panel de informaciÃ³n
        function closeInfoPanel() {
          const existingPanel = scene.getObjectByName('infoPanel');
          if (existingPanel) {
            scene.remove(existingPanel);
            isInfoPanelOpen = false;
          }
        }

        // FunciÃ³n para reproducir video 360Â°
        function playVideo360() {
          if (isVideoPlaying) return; // Evitar mÃºltiples reproducciones
          
          isVideoPlaying = true;
          debug('Iniciando video 360Â°...');
          
          // Guardar escena original
          originalScene = scene;
          originalCamera = camera;
          
          // Crear escena de video
          videoScene = new THREE.Scene();
          videoCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
          videoCamera.position.set(0, 0, 0);
          
          // Crear video texture
          const video = document.createElement('video');
          video.src = 'https://ikan-bucket.s3.us-east-2.amazonaws.com/go2.mp4';
          video.loop = false;
          video.muted = false; // Habilitar audio
          video.volume = 0.7; // Volumen al 70%
          video.crossOrigin = 'anonymous';
          
          // Guardar referencia al video actual
          currentVideo = video;
          
          const videoTexture = new THREE.VideoTexture(video);
          videoTexture.minFilter = THREE.LinearFilter;
          videoTexture.magFilter = THREE.LinearFilter;
          
          // Crear skybox con video
          const videoGeometry = new THREE.SphereGeometry(100, 32, 32);
          const videoMaterial = new THREE.MeshBasicMaterial({ 
            map: videoTexture, 
            side: THREE.BackSide 
          });
          const videoSkybox = new THREE.Mesh(videoGeometry, videoMaterial);
          videoScene.add(videoSkybox);
          
          // Cambiar a escena de video
          scene = videoScene;
          camera = videoCamera;
          
          // Reproducir video con audio
          video.play().then(() => {
            debug('Video iniciado correctamente con audio');
          }).catch(err => {
            debug(`Error reproduciendo video: ${err.message}`);
            // Si falla por audio, intentar sin audio
            video.muted = true;
            video.play().then(() => {
              debug('Video iniciado sin audio (fallback)');
            }).catch(err2 => {
              debug(`Error final: ${err2.message}`);
            });
          });
          
          // FunciÃ³n de render para video
          function renderVideo() {
            if (videoTexture.image && videoTexture.image.readyState === videoTexture.image.HAVE_ENOUGH_DATA) {
              videoTexture.needsUpdate = true;
            }
            renderer.render(scene, camera);
          }
          
          // Cambiar el loop de animaciÃ³n
          if (renderer.xr.isPresenting) {
            renderer.setAnimationLoop(renderVideo);
          } else {
            const videoAnimationLoop = () => {
              renderVideo();
              if (isVideoPlaying) {
                requestAnimationFrame(videoAnimationLoop);
              }
            };
            videoAnimationLoop();
          }
          
          // Detener despuÃ©s de 20 segundos
          setTimeout(() => {
            stopVideo360();
          }, 20000);
        }

        // FunciÃ³n para detener video y regresar a escena principal
        function stopVideo360() {
          if (!isVideoPlaying) return;
          
          isVideoPlaying = false;
          debug('Regresando a escena principal...');
          
          // Detener y limpiar el video
          if (currentVideo) {
            currentVideo.pause();
            currentVideo.currentTime = 0;
            currentVideo.src = '';
            currentVideo.load();
            currentVideo = null;
          }
          
          // Restaurar escena original
          scene = originalScene;
          camera = originalCamera;
          
          // Limpiar recursos de video
          if (videoScene) {
            videoScene.traverse((object) => {
              if (object.material) {
                object.material.dispose();
              }
              if (object.geometry) {
                object.geometry.dispose();
              }
            });
            videoScene = null;
          }
          
          videoCamera = null;
          originalScene = null;
          originalCamera = null;
        }

        // FunciÃ³n para mostrar informaciÃ³n del objeto
        function showObjectInfo(object) {
          if (object.userData && object.userData.name) {
            debug(`INFO: ${object.userData.name}`);
            
            // Remover panel anterior si existe
            closeInfoPanel();
            
            // Crear panel 3D de informaciÃ³n
            const panelGroup = new THREE.Group();
            panelGroup.name = 'infoPanel';
            
            // Fondo del panel
            const panelGeometry = new THREE.PlaneGeometry(1.5, 0.8);
            const panelMaterial = new THREE.MeshBasicMaterial({ 
              color: 0x000000, 
              transparent: true, 
              opacity: 0.9 
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            panelGroup.add(panel);
            
            // Crear canvas para el texto
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Configurar el canvas
            context.fillStyle = '#000000';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar texto
            context.fillStyle = '#ffffff';
            context.font = 'bold 32px Arial';
            context.textAlign = 'center';
            
            // TÃ­tulo
            context.fillText(object.userData.name, canvas.width/2, 50);
            
            // InformaciÃ³n (dividida en lÃ­neas)
            context.font = '20px Arial';
            const words = object.userData.info.split(' ');
            let lines = [];
            let currentLine = '';
            
            for (let word of words) {
              const testLine = currentLine + word + ' ';
              if (context.measureText(testLine).width > canvas.width - 40) {
                lines.push(currentLine);
                currentLine = word + ' ';
              } else {
                currentLine = testLine;
              }
            }
            lines.push(currentLine);
            
            // Dibujar lÃ­neas de informaciÃ³n
            lines.forEach((line, index) => {
              context.fillText(line, canvas.width/2, 90 + (index * 30));
            });
            
            // Crear textura del canvas
            const texture = new THREE.CanvasTexture(canvas);
            const textGeometry = new THREE.PlaneGeometry(1.5, 0.8);
            const textMaterial = new THREE.MeshBasicMaterial({ 
              map: texture,
              transparent: true,
              side: THREE.DoubleSide
            });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            panelGroup.add(textMesh);
            
            // Crear botÃ³n de video solo para Unitree Go2
            if (object.userData.name === 'Unitree Go2') {
              const buttonGeometry = new THREE.PlaneGeometry(0.4, 0.15);
              const buttonMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
              const videoButton = new THREE.Mesh(buttonGeometry, buttonMaterial);
              videoButton.name = 'videoButton';
              videoButton.userData = { type: 'videoButton', object: object };
              
              // Posicionar el botÃ³n debajo del panel
              videoButton.position.set(0, -0.6, 0);
              panelGroup.add(videoButton);
              
              // Agregar el botÃ³n a la lista de interactivos
              interactables.push(videoButton);
            }
            
            // Posicionar el panel cerca del objeto
            const objectPosition = object.position.clone();
            panelGroup.position.copy(objectPosition);
            panelGroup.position.y += 1; // Elevar un poco
            panelGroup.position.z += 0.5; // Acercar a la cÃ¡mara
            
            // Hacer que el panel mire hacia la cÃ¡mara
            panelGroup.lookAt(camera.position);
            
            scene.add(panelGroup);
            isInfoPanelOpen = true;
          }
        }

        // FunciÃ³n para manejar selecciÃ³n (agarrar o seleccionar)
        function onSelectStart(event) {
          const controller = event.target;
          
          // Configurar raycaster desde el controlador
          tempMatrix.identity().extractRotation(controller.matrixWorld);
          raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
          raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

          // Detectar objetos intersectados
          const intersects = raycaster.intersectObjects(interactables);
          
          debug(`Objetos intersectados: ${intersects.length}`);
          
          if (intersects.length > 0) {
            const hitObject = intersects[0].object;
            debug(`Objeto golpeado: ${hitObject.name || 'sin nombre'}`);
            
            // Si es el cubo principal, permitir agarrarlo
            if (hitObject === cube) {
              grabbedObject = hitObject;
              controller.attach(grabbedObject);
              debug('Cubo agarrado');
              grabbedObject.material.color.setHex(0xff0000); // Rojo cuando agarrado
            } else if (hitObject.name === 'videoButton') {
              // Si es el botÃ³n de video, reproducir video
              debug('BotÃ³n de video presionado - iniciando video');
              playVideo360();
              
              // Efecto visual del botÃ³n
              hitObject.material.color.setHex(0xffff00); // Amarillo temporal
              setTimeout(() => {
                hitObject.material.color.setHex(0x00ff00); // Volver a verde
              }, 200);
            } else {
              // Si es un objeto estÃ¡tico, manejar toggle de informaciÃ³n
              if (selectedObject === hitObject) {
                // Si ya estÃ¡ seleccionado, deseleccionarlo
                closeInfoPanel();
                hitObject.material.color.setHex(0xffffff); // Volver a blanco
                selectedObject = null;
                lastSelectedObject = null;
                debug('Deseleccionado');
              } else {
                // Si no estÃ¡ seleccionado, seleccionarlo
                // Restaurar color del objeto anteriormente seleccionado
                if (selectedObject) {
                  selectedObject.material.color.setHex(0xffffff); // Blanco para Pepper
                }
                
                selectedObject = hitObject;
                showObjectInfo(selectedObject);
                debug(`Seleccionado: ${selectedObject.userData.name}`);
                
                // Mantener color verde mientras estÃ¡ seleccionado
                selectedObject.material.color.setHex(0x00ff00); // Verde
                lastSelectedObject = selectedObject;
              }
            }
          }
        }

        // FunciÃ³n para manejar fin de selecciÃ³n (soltar)
        function onSelectEnd(event) {
          if (grabbedObject) {
            scene.attach(grabbedObject);
            grabbedObject = null;
            debug('Cubo soltado');
            cube.material.color.setHex(0xffaa00); // Restaurar color amarillo
          }
        }

        // FunciÃ³n para actualizar indicadores visuales
        function updateControllerIndicators() {
          [controller1, controller2].forEach(controller => {
            const line = controller.getObjectByName('line');
            const cursor = controller.getObjectByName('cursor');
            
            if (line && cursor) {
              // Configurar raycaster
              tempMatrix.identity().extractRotation(controller.matrixWorld);
              raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
              raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

              // Detectar objetos
              const intersects = raycaster.intersectObjects(interactables);
              
              if (intersects.length > 0) {
                // Mostrar cursor en el punto de intersecciÃ³n
                cursor.position.copy(intersects[0].point);
                cursor.lookAt(controller.position);
                cursor.visible = true;
                
                // Cambiar color segÃºn el tipo de objeto
                const hitObject = intersects[0].object;
                if (hitObject === cube) {
                  cursor.material.color.setHex(0x00ff00); // Verde para cubo mÃ³vil
                  line.material.color.setHex(0x00ff00);
                } else if (hitObject.name === 'videoButton') {
                  cursor.material.color.setHex(0xff0000); // Rojo para botÃ³n de video
                  line.material.color.setHex(0xff0000);
                } else {
                  cursor.material.color.setHex(0xffff00); // Amarillo para objetos informativos
                  line.material.color.setHex(0xffff00);
                }
                
                line.scale.z = intersects[0].distance;
              } else {
                // Ocultar cursor si no hay objetos
                cursor.visible = false;
                
                // Color normal para el rayo
                line.material.color.setHex(0xffffff);
                line.scale.z = 5;
              }
            }
          });
        }

        // FunciÃ³n para mostrar coordenadas de objetos
        function showObjectCoordinates() {
          const coordinates = [];
          
          // Coordenadas del cubo
          coordinates.push(`Cubo: (${cube.position.x.toFixed(2)}, ${cube.position.y.toFixed(2)}, ${cube.position.z.toFixed(2)})`);
          
          // Coordenadas de Pepper
          coordinates.push(`Pepper: (${pepper.position.x.toFixed(2)}, ${pepper.position.y.toFixed(2)}, ${pepper.position.z.toFixed(2)})`);
          
          // Coordenadas de Unitree
          coordinates.push(`Unitree: (${unitree.position.x.toFixed(2)}, ${unitree.position.y.toFixed(2)}, ${unitree.position.z.toFixed(2)})`);
          
          // Mostrar en debug
          debug(`Posiciones: ${coordinates.join(' | ')}`);
        }

        // FunciÃ³n para actualizar coordenadas cada segundo
        function updateCoordinates() {
          if (!isVideoPlaying) {
            showObjectCoordinates();
          }
        }

        // Actualizar coordenadas cada segundo
        setInterval(updateCoordinates, 1000);

        // Variable para controlar la animaciÃ³n
        let animationId = null;

        // Agregar eventos a ambos controladores
        controller1.addEventListener('selectstart', onSelectStart);
        controller1.addEventListener('selectend', onSelectEnd);
        controller2.addEventListener('selectstart', onSelectStart);
        controller2.addEventListener('selectend', onSelectEnd);

        // FunciÃ³n de animaciÃ³n que funciona en ambos modos
        function animate() {
          // Rotar el cubo solo si no estÃ¡ agarrado
          if (!grabbedObject) {
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;
          }
          
          // Actualizar indicadores visuales
          updateControllerIndicators();
          
          // Renderizar
          renderer.render(scene, camera);
          
          // Continuar animaciÃ³n solo en modo no-VR
          if (!renderer.xr.isPresenting) {
            animationId = requestAnimationFrame(animate);
          }
        }

        // Iniciar animaciÃ³n no-VR
        animate();

        // Manejar entrada/salida de VR
        renderer.xr.addEventListener('sessionstart', () => {
          debug('SesiÃ³n VR iniciada - Usa el gatillo para agarrar el cubo');
        });

        renderer.xr.addEventListener('sessionend', () => {
          debug('SesiÃ³n VR terminada');
          // Reanudar animaciÃ³n no-VR
          animate();
        });

        debug('Escena interactiva lista');
      } catch (err) {
        debug(`Error en escena: ${err.message}`);
        console.error(err);
      }
    }

    // FunciÃ³n para entrar en VR
    async function enterVR() {
      debug('Intentando entrar en VR...');
      
      if (!navigator.xr) {
        debug('WebXR no disponible');
        return;
      }

      try {
        vrButton.style.display = 'none';
        
        const session = await navigator.xr.requestSession('immersive-vr', {
          optionalFeatures: ['local-floor', 'bounded-floor'],
          requiredFeatures: ['local']
        });

        await renderer.xr.setSession(session);
        renderer.xr.setReferenceSpaceType('local');
        
        debug('VR activo - Agarra el cubo con el gatillo');
        
        // Configurar el loop de animaciÃ³n para VR
        renderer.setAnimationLoop((time, frame) => {
          // La rotaciÃ³n se maneja en la funciÃ³n animate()
          renderer.render(scene, camera);
        });
      } catch (err) {
        debug(`Error VR: ${err.message}`);
        vrButton.style.display = 'block';
        console.error(err);
      }
    }

    // InicializaciÃ³n cuando el DOM estÃ© listo
    document.addEventListener('DOMContentLoaded', function() {
      debug('DOM listo');
      
      // Cargar Three.js dinÃ¡micamente
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/three@0.151.0/build/three.min.js';
      script.onload = function() {
        debug('Three.js cargado');
        window.THREE = THREE;
        checkWebXR();
        initScene();
        debug('InicializaciÃ³n completa');
      };
      script.onerror = function() {
        debug('Error cargando Three.js');
      };
      document.head.appendChild(script);
    });

    // Hacer enterVR global
    window.enterVR = enterVR;
  </script>
</body>
</html>
